/*私有（private）成员(默认)：
* 只允许本类的成员函数来访问
*公有（public）成员：
* 类对外的接口，在类声明和类（函数）实现之后，类的对象可以访问公有成员。
*保护型（protected）成员:
* 可访问性和私有成员的性质相似，在学习“继承”时再理解。 
*/
/*
* 构造函数是一种特殊的成员函数
构造函数与类同名；
构造函数在建立对象时自动执行；
构造函数不具有任何类型，不返回任何值；
构造函数的功能是由用户定义的，用户根据初始化的要求设计函数体和函数参数；
如果用户自己没有定义构造函数，则C++系统会自动生成一个默认构造函数(没有参数的构造函数)；自动生成的
默认构造函数是个空函数，不执行任何操作。
若用户定义了构造函数，编译器则不会自动添加默认构造函数

*/

//在声明对象时，会自动调用构造函数
#include<iostream>
using namespace std;
#include<string>
class student
{
public:                              /*
									 构造函数与类同名，且没有返回类型，但是并不写成void,实
									 际上是，
									 构造函数没有声明类型          
									 */
	student(string name, int age);//需要参数的构造函数 

    student();                      //这是一个没有参数的构造函数。
	                                
	//student(string name, int age = 3);//这是一个只有一个默认参数的构造函数
	                                  //因为传参时是从左往右进行，因而，如果参数是默认参数，
	                                  //函数参数列表中应该是从右往左排默认参数。


	//student(string name = "李四", int age = 4)//这是一个全都是默认参数的构造函数，并且写
	                                          // 在类定义里面
											  //这样会被解释为内联函数。
											  //在类的内部定义的构造函数是内联函数。
	//{
	//	m_name = name;
	//	m_age = age;
	//}
	//类的数据成员不能在声明类时初始化。
	//C11标准允许这么做
	void display()
	{
		cout << "name:" << " " << m_name << endl;
		cout << "age:" << " " << m_age << endl;
	}

private:
	string m_name;
	int m_age;
};
student::student(string name, int age)
{
	m_name = name;
	m_age = age;
}
student::student()             //默认构造函数也就是无参构造函数，意为创建对象时不用写参数。
                               //当然也不用写（）,
	                           //如果写student a();这实际上是一个返回student类型的无参函数
{                              //换一句话说，就是没有提供参数时，调用这个构造函数
	m_name = "张三";           //这种构造函数叫做无参构造函数，不接受参数，但是有赋值语句
	m_age = 18;                //这样的话，创建对象时不用写参数，也就是隐式初始化。
}                              //如果构造函数全都是默认参数的，那么在创建对象时也不用写参数列表，因而
	                           //也叫做无参构造函数
	                           //如果没有主动写一个默认构造函数，那系统会自动创建一个默认构造函数
	                           //为：类名（）{}    什么也不做，只是让程序能先运行不报错
	                           //要注意的是，如果写了有参的构造函数，那么系统就不会自动创建默认构造函数
	                           //也就是说，最好自己把默认构造参数写上
                               //尤其要注意的是，两种写法的默认（无参）构造函数不可以同时存在，不然不
                               //知道用哪一个，会报错
	                           //区别在于，全部都是默认参数的构造函数可以接受参数
//student::student(string  name, int age = 3)
//{
//	m_name = name;
//	m_age = age;
//}


//在类的外面实现构造函数，类名::类名（参数列表）{}           
// 注意！构造函数一定是公有成员。
//实际上也可以在类里面实现构造函数，这样的话，也就是不用声明，直接定义
//构造函数可以重载，同时可以是默认参数，这里再写几个构造函数，写在类里面或者类外面，注意写法，在类里
//面直接定义，不用写类名::表示作用域

int main()
{
	student a("李四",14);//调用含参构造函数
	//student b=student("张三");     //只有部分参数为默认参数的构造函数，调用时会报错，
	                                 // 说找不到这个重载
	                               //大概是因为默认参数不是造成重载的因素，也就是说，
								   // 参数数量和类型相同
	                               //的同名（返回值类型相同）函数才是重载关系。
	                               //且仅返回类型不同的函数无法区分，所以无法造成重载
	student c;         //调用了无参（默认）构造函数
	student d = student("王五",19);//显示的调用构造函数

	cout << "a：" << endl;
	a.display();
	cout << "c:";
	c.display();
	cout << "d:" << endl;
	d.display();

	return 0;
}
